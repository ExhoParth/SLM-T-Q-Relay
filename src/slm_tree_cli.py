import typer
from transformers import AutoTokenizer, AutoModelForCausalLM
from typing import List, Dict, Optional

# CLI application
app = typer.Typer()

class SLMNode:
    """
    Represents a node in the SLM tree.
    Each node can answer queries or forward them to child nodes based on the response.
    """
    def __init__(self, name: str, model_path: str, description: str):
        self.name = name
        self.model_path = model_path
        self.description = description
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model = AutoModelForCausalLM.from_pretrained(model_path)
        self.children = {}  # A dictionary to store child nodes {name: SLMNode}

    def add_child(self, child_name: str, child_path: str, child_description: str):
        """
        Add a child node to the current node.

        Args:
        - child_name: Name of the child node.
        - child_path: Path to the child model.
        - child_description: Description of the child node.
        """
        if child_name not in self.children:
            self.children[child_name] = SLMNode(child_name, child_path, child_description)
        else:
            raise ValueError(f"Child node '{child_name}' already exists!")

    def forward(self, query: str) -> str:
        """
        Process a query using the current node's model or forward it to a child node.

        Args:
        - query: The query string to process.

        Returns:
        - Response generated by the current node or forwarded to a child node.
        """
        # Construct a system prompt including child names and descriptions
        system_prompt = f"Child Nodes:\n" + "\n".join(
            [f"- {name}: {node.description}" for name, node in self.children.items()]
        )
        system_prompt += f"\nBased on the query, decide whether to answer or forward to a child.\n\nQuery: {query}"

        # Combine query with the system prompt
        inputs = self.tokenizer(system_prompt, return_tensors="pt", truncation=True)
        output = self.model.generate(**inputs, max_length=200)
        response = self.tokenizer.decode(output[0], skip_special_tokens=True)

        # Check if the response matches a child node's name
        if response in self.children:
            # Forward the query to the relevant child node
            return self.children[response].forward(query)
        else:
            # Return the response if it does not match a child node
            return response


class SLMTree:
    """
    Represents the entire SLM tree structure.
    """
    def __init__(self, root_node: SLMNode):
        self.root_node = root_node

    def route_query(self, query: str) -> str:
        """
        Route a query starting from the root node.

        Args:
        - query: The query string to route.

        Returns:
        - Response generated by the SLM Tree.
        """
        return self.root_node.forward(query)

    def add_child_to_node(
        self, parent_name: str, child_name: str, child_path: str, child_description: str
    ):
        """
        Add a child node to a specific parent node.

        Args:
        - parent_name: Name of the parent node.
        - child_name: Name of the child node.
        - child_path: Path to the child model.
        - child_description: Description of the child node.
        """
        parent_node = self._find_node(self.root_node, parent_name)
        if parent_node:
            parent_node.add_child(child_name, child_path, child_description)
        else:
            raise ValueError(f"Parent node '{parent_name}' not found!")

    def _find_node(self, current_node: SLMNode, target_name: str) -> Optional[SLMNode]:
        """
        Recursively find a node by its name.

        Args:
        - current_node: The node to start searching from.
        - target_name: The name of the node to find.

        Returns:
        - The node if found, otherwise None.
        """
        if current_node.name == target_name:
            return current_node

        for child in current_node.children.values():
            result = self._find_node(child, target_name)
            if result:
                return result
        return None


@app.command()
def create_tree(root_name: str, root_model_path: str, root_description: str):
    """
    Create an SLM Tree with a root node.

    Args:
    - root_name: Name of the root node.
    - root_model_path: Path to the root node model.
    - root_description: Description of the root node.
    """
    global slm_tree
    root_node = SLMNode(root_name, root_model_path, root_description)
    slm_tree = SLMTree(root_node)
    typer.echo(f"SLM Tree created with root node '{root_name}'")


@app.command()
def add_child(parent_name: str, child_name: str, child_path: str, child_description: str):
    """
    Add a child node to an existing parent node in the tree.

    Args:
    - parent_name: Name of the parent node.
    - child_name: Name of the child node.
    - child_path: Path to the child model.
    - child_description: Description of the child node.
    """
    if not slm_tree:
        typer.echo("Please create an SLM Tree first.")
        return

    try:
        slm_tree.add_child_to_node(parent_name, child_name, child_path, child_description)
        typer.echo(f"Child node '{child_name}' added to parent '{parent_name}'")
    except ValueError as e:
        typer.echo(str(e))


@app.command()
def route_query(query: str):
    """
    Route a query through the SLM Tree.

    Args:
    - query: The query string to route.
    """
    if not slm_tree:
        typer.echo("Please create an SLM Tree first.")
        return

    response = slm_tree.route_query(query)
    typer.echo(f"Response: {response}")


if __name__ == "__main__":
    slm_tree = None  # Initialize the global SLM Tree
    app()
